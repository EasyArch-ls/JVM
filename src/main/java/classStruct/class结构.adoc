### 魔数与Class文件的版本

* 魔数（值为0xCAFEBABE）：每个Class文件的头4个字节被称为魔数(M agic Number),它的唯一作用是确定这个文件是否为
 一个能被虚拟机接受的Class文件
* 版本号：紧接着魔数的4个字节存储的是Class文件的版本号:第5和第6个字节是次版本号(Minor
 Version),第7和第8个字节是主版本号(Major Version)

### 常量池(javap -verbose )

* 位置：紧接着主、次版本号之后的是常量池入口。由于常量池中常量的数量是不固定的,所以在常量池的入口需要放置一项u2类型的数据,代表常
 量池容量计数值(constant_pool_count)，这个容量计数是从1而不是0开始.
* 分类：常量池中存储的常量可分为：字面量(Literal)和符号引用(Symbolic References)
- *字面量*：如文本字符串、被声明为final的常量值等
- *符号引用*： 1.被模块导出或者开放的包(Package)
            2.类和接口的全限定名(Fully Qualified Name)
            3.字段的名称和描述符(Descriptor)
            4.方法的名称和描述符
            5.方法句柄和方法类型(M ethod Handle、M ethod Type、Invoke Dynamic)
            6.·动态调用点和动态常量(Dynamically-Computed Call Site、Dynamically-Computed Constant)  
            
### 访问标志
 * 在常量池结束之后,紧接着的2个字节代表访问标志(access_flags),这个标志用于识别一些类或
   者接口层次的访问信息,包括:这个Class是类还是接口;是否定义为public类型;是否定义为abstract
   类型;如果是类的话,是否被声明为final;等等。access_flags中一共有16个标志位可以使用,当前只定义了其中9个 [1] ,没有使用到的标志位要求一
   律为零。

### 类索引、父类索引与接口索引集合
* 类型：类索引(this_class)和父类索引(super_class)都是一个u2类型的数据,而接口索引集合
(interfaces)是一组u2类型的数据的集合
* 作用：类索 引用于确定这个类的全限定名,父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多
重继承,所以父类索引只有一个,除了java.lang.Object之外,所有的Java类都有父类,因此除了
java.lang.Object外,所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接
口,这些被实现的接口将按implements关键字(如果这个Class文件表示的是一个接口,则应当是
extends关键字)后的接口顺序从左到右排列在接口索引集合中

### 字段表集合
* 含义：字段表(field_info)用于描述接口或者类中声明的变量。包括类级变
量以及实例级变量,但不包括在方法内部声明的局部变量。字段可以包括的修饰符有字段的作用域(public、private、protected修饰
符)、是实例变量还是类变量(static修饰符)、可变性(final)、并发可见性(volatile修饰符,是否
强制从主内存读写)、可否被序列化(transient修饰符)、字段数据类型(基本类型、对象、数组)、
字段名称
* 解释：
- access_flags：字段修饰符
- name_index和descriptor_index分别代表着字段的简单名称以及字段和方法的描述符
(全限定名:表示类的全限定名; 简单名称：指没有类型和参数修饰的方法或者字段名称; 描述符：描述符的作用是用来描述字段
的数据类型、方法的参数列表(包括数量、类型以及顺序)和返回值)

### 方法表集合
* 依次包括访问标志(access_flags)、名称索引(name_index)、描述符索引(descriptor_index)、属性表
集合(attributes)几项
* volatile关键字和transient关键字不能修饰方法,所以方法表的访问标志中没有
* 重载(Overload)一个方法,除了要与原方法具有相同的简单名称之外,还要求
必须拥有一个与原方法不同的特征签名(Java代码的方法特征签名只包括方法名称、参数
顺序及参数类型,而字节码的特征签名还包括方法返回值以及受查异常表)

### 属性表集合
* Class文件、字段表、方法表都可以携带自己的属性表集合,以描述某些场景专有的信息
* 1.Code属性
- Java程序方法体里面的代码经过Javac编译器处理之后,最终变为字节码指令存储在Code属性内。
Code属性出现在方法表的属性集合之中,但并非所有的方法表都必须存在这个属性,譬如接口或者抽
象类中的方法就不存在Code属性
- 结构:
##**__attribute_name_index__**##是一项指向CONSTANT_Utf8_info型常量的索引,此常量值固定为“Code”,它
代表了该属性的属性名称,attribute_length指示了属性值的长度,由于属性名称索引与属性长度一共为
6个字节,所以属性值的长度固定为整个属性表长度减去6个字节。 ##**__max_stack__**##代表了操作数栈(Operand Stack)深度的最大值。在方法执行的任意时刻,操作数栈都
不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧(Stack Frame)中的操作栈深度。
##__**max_locals**__##代表了局部变量表所需的存储空间。在这里,max_locals的单位是##变量槽##(Slot),变量
槽是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和
returnAddress等长度不超过32位的数据类型,每个局部变量占用一个变量槽,而double和long这两种64
位的数据类型则需要两个变量槽来存放。方法参数(包括实例方法中的隐藏参数“this”)、显式异常处
理程序的参数(Exception Handler Parameter,就是try-catch语句中catch块中所定义的异常)、方法体中
定义的局部变量都需要依赖局部变量表来存放。注意,并不是在方法中用了多少个局部变量,就把这
些局部变量所占变量槽数量之和作为max_locals的值,操作数栈和局部变量表直接决定一个该方法的栈
帧所耗费的内存,不必要的操作数栈深度和变量槽数量会造成内存的浪费。#Java虚拟机的做法是将局
部变量表中的变量槽进行重用#,当代码执行超出一个局部变量的作用域时,这个局部变量所占的变量
槽可以被其他局部变量所使用,Javac编译器会根据变量的作用域来分配变量槽给各个变量使用,根据
同时生存的最大局部变量数量和类型计算出max_locals的大小。##__**code_length和code**__##用来存储Java源程序编译后生成的字节码指令。code_length代表字节码长度,
code是用于存储字节码指令的一系列字节流
* Code属性是Class文件中最重要的一个属性,如果把一个Java程序中的信息分为代码(Code,方法
体里面的Java代码)和元数据(M etadata,包括类、字段、方法定义及其他信息)两部分,那么在整
个Class文件里,Code属性用于描述代码,所有的其他数据项目都用于描述元数据
* Java语言里面的潜规则:在任何实例方法里面,都可以通过“this”关键字访问到此方
法所属的对象。这个访问机制对Java程序的编写很重要,而它的实现非常简单,仅仅是通过在Javac编
译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问,然后在虚拟机调用实例方法
时自动传入此参数而已。因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变
量,局部变量表中也会预留出第一个变量槽位来存放对象实例的引用

