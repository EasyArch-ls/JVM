### 对象的初始化过程 （参考one中的例子）
* 父类的静态变量和静态代码块
* 子类的静态变量和静态代码块
* 父类的成员变量和方法块
* 父类的构造函数
* 子类的成员变量和方法块
* 子类的构造函数

### 创建对象的几种方式
* new关键字
* 使用Class对象的newInstance()方法
* 构造函数对象的newInstance()方法
* 对象反序列化
* Object对象的clone()方法
* 反射方法
* 使用Unsafe类创建对象

### 对象的创建
* 先去检查这个指令的参数是否能在常量池中定位到
一个类的符号引用,并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有,那
必须先执行相应的类加载过程

* 在类加载检查通过后,接下来虚拟机将为新生对象##__**分配内存**__##。对象所需内存的大小在类加载完成
后便可完全确定,为对象分配空间的任务实际上便等同于把一块确定
大小的内存块从Java堆中划分出来。假设Java堆中内存是绝对规整的,所有被使用过的内存都被放在一
边,空闲的内存被放在另一边,中间放着一个指针作为分界点的指示器,那所分配内存就仅仅是把那
个指针向空闲空间方向挪动一段与对象大小相等的距离,这种分配方式称为“指针碰撞”(Bump The
Pointer)。但如果Java堆中的内存并不是规整的,已被使用的内存和空闲的内存相互交错在一起,那
就没有办法简单地进行指针碰撞了,虚拟机就必须维护一个列表,记录上哪些内存块是可用的,在分
配的时候从列表中找到一块足够大的空间划分给对象实例,并更新列表上的记录,这种分配方式称
为“空闲列表”(Free List)。选择哪种分配方式由Java堆是否规整决定,而Java堆是否规整又由所采用
的垃圾收集器是否带有空间压缩整理(Compact)的能力决定。因此,当使用Serial、ParNew等带压缩
整理过程的收集器时,系统采用的分配算法是指针碰撞,既简单又高效;而当使用CM S这种基于清除
(Sweep)算法的收集器时,理论上就只能采用较为复杂的空闲列表来分配内存。(CM S的实现里面,为了能在多数情况下分配得更快,设计了一个叫作Linear
Allocation Buffer的分配缓冲区,通过空闲列表拿到一大块分配缓冲区之后,在它里面仍然可以使用指
针碰撞方式来分配。)
- 解决并发创建：一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败
重试的方式保证更新操作的原子性;另外一种是把内存分配的动作按照线程划分在不同的空间之中进
行,即每个线程在Java堆中预先分配一小块内存,称为本地线程分配缓冲(Thread Local Allocation
Buffer,TLAB),哪个线程要分配内存,就在哪个线程的本地缓冲区中分配,只有本地缓冲区用完
了,分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB,可以通过-XX:+/-UseTLAB参数来
设定。

* 内存分配完成之后,虚拟机必须将分配到的内存空间(但不包括对象头)都##__**初始化为零值**__##,如果
使用了TLAB的话,这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段
在Java代码中可以不赋初始值就直接使用,使程序能访问到这些字段的数据类型所对应的零值

* 接下来,Java虚拟机还要对对象进行必要的设置,例如这个对象是哪个类的实例、如何才能找到
类的元数据信息、对象的哈希码(实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才
计算)、对象的GC分代年龄等信息。这些信息存放在对象的对象头(Object Header)之中。根据虚拟
机当前运行状态的不同,如是否启用偏向锁等,对象头会有不同的设置方式。

* 执行构造函数，即Class文件中的<init>()方法

### 对象的内存布局
* 在HotSpot虚拟机里,对象在堆内存中的存储布局可以划分为三个部分:对象头(Header)、实例
数据(Instance Data)和对齐填充(Padding)。
* 对象头(Mark Word)：
- #*_第一类是用于存储对象自身的运行时数据_*#,如哈
希码(HashCode)、##__**GC分代年龄(4位标志，如果在Survivor空间中相同年龄所有对象大小的总和大于
Survivor空间的一半,年龄大于或等于该年龄的对象就可以直接进入老年代,无须等到-XX:
M axTenuringThreshold（默认是15）**__##中要求的年龄。)、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
#_*对象头的另外一部分是类型指针*_#,即对象指向它的类型元数据的指针,Java虚拟机通过这个指针
来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针,换句话
说,查找对象的元数据信息并不一定要经过对象本身.此外,如果对
象是一个Java数组,那在对象头中还必须有一块用于记录数组长度的数据,因为虚拟机可以通过普通
Java对象的元数据信息确定Java对象的大小,但是如果数组的长度是不确定的,将无法通过元数据中的
信息推断出数组的大小。
* 实例数据：
- 我们在程序代码里面所定义的各种类型的字
段内容,无论是从父类继承下来的,还是在子类中定义的字段都必须记录起来。这部分的存储顺序会
受到虚拟机分配策略参数(-XX:FieldsAllocationStyle参数)和字段在Java源码中定义顺序的影响。
HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary
Object Pointers,OOPs),从以上默认的分配策略中可以看到,相同宽度的字段总是被分配到一起存
放,在满足这个前提条件的情况下,在父类中定义的变量会出现在子类之前。如果HotSpot虚拟机的
+XX:CompactFields参数值为true(默认就为true),那子类之中较窄的变量也允许插入父类变量的空
隙之中,以节省出一点点空间。
* 对齐填充:
- 仅仅起着占位符的作
用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍,换句话说就是
任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数(1倍或者
2倍),因此,如果对象实例数据部分没有对齐的话,就需要通过对齐填充来补全。

### 对象的访问定位
* 通过句柄池访问：如果使用句柄访问的话,Java堆中将可能会划分出一块内存来作为句柄池,reference中存储的就
是对象的句柄地址,而句柄中包含了对象实例数据与类型数据各自具体的地址信息
* 通过直接指针去访问：如果使用直接指针访问的话,Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关
信息,reference中存储的直接就是对象地址,如果只是访问对象本身的话,就不需要多一次间接访问
的开销
